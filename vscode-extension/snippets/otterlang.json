{
    "Function Definition": {
        "prefix": "def",
        "body": [
            "fn ${1:function_name}(${2:params}):",
            "    ${0:pass}"
        ],
        "description": "Define a new function"
    },
    "Struct Definition": {
        "prefix": "struct",
        "body": [
            "struct ${1:StructName}:",
            "    ${2:field}: ${3:Type}",
            "    ${0}"
        ],
        "description": "Define a new struct"
    },
    "If Statement": {
        "prefix": "if",
        "body": [
            "if ${1:condition}:",
            "    ${0:pass}"
        ],
        "description": "If statement"
    },
    "If-Else Statement": {
        "prefix": "ife",
        "body": [
            "if ${1:condition}:",
            "    ${2:pass}",
            "else:",
            "    ${0:pass}"
        ],
        "description": "If-else statement"
    },
    "If-Elif-Else Statement": {
        "prefix": "ifel",
        "body": [
            "if ${1:condition}:",
            "    ${2:pass}",
            "elif ${3:condition}:",
            "    ${4:pass}",
            "else:",
            "    ${0:pass}"
        ],
        "description": "If-elif-else statement"
    },
    "For Loop": {
        "prefix": "for",
        "body": [
            "for ${1:item} in ${2:iterable}:",
            "    ${0:pass}"
        ],
        "description": "For loop"
    },
    "For Range Loop": {
        "prefix": "forr",
        "body": [
            "for ${1:i} in ${2:0}..${3:10}:",
            "    ${0:pass}"
        ],
        "description": "For loop with range"
    },
    "While Loop": {
        "prefix": "while",
        "body": [
            "while ${1:condition}:",
            "    ${0:pass}"
        ],
        "description": "While loop"
    },
    "Result Enum": {
        "prefix": "result",
        "body": [
            "enum Result<T, E>:",
            "    Ok: (T)",
            "    Err: (E)"
        ],
        "description": "Result enum definition"
    },
    "Result Function": {
        "prefix": "resfn",
        "body": [
            "fn ${1:function_name}(${2:param}: ${3:Type}) -> Result<${4:ReturnType}, ${5:ErrorType}>:",
            "    if ${6:condition}:",
            "        return Result.Err(\"${7:error}\")",
            "    return Result.Ok(${0:value})"
        ],
        "description": "Function returning Result"
    },
    "Match Result": {
        "prefix": "resmat",
        "body": [
            "match ${1:result}:",
            "    case Result.Ok(${2:value}):",
            "        ${3:pass}",
            "    case Result.Err(${4:error}):",
            "        ${0:pass}"
        ],
        "description": "Match Result with Ok/Err cases"
    },
    "Match Statement": {
        "prefix": "match",
        "body": [
            "match ${1:value}:",
            "    case ${2:pattern}:",
            "        ${0:pass}"
        ],
        "description": "Match statement"
    },
    "Match Enum": {
        "prefix": "matchenum",
        "body": [
            "match ${1:enum_value}:",
            "    case ${2:EnumName}.${3:Variant1}:",
            "        ${4:pass}",
            "    case ${5:EnumName}.${6:Variant2}:",
            "        ${0:pass}"
        ],
        "description": "Match enum with multiple variants"
    },
    "Print": {
        "prefix": "print",
        "body": [
            "print(${0:value})"
        ],
        "description": "Print statement"
    },
    "Main Function": {
        "prefix": "main",
        "body": [
            "fn main():",
            "    ${0:pass}"
        ],
        "description": "Main function template"
    },
    "List Comprehension": {
        "prefix": "lc",
        "body": [
            "[${1:expr} for ${2:item} in ${3:iterable}]"
        ],
        "description": "List comprehension"
    },
    "Dict Comprehension": {
        "prefix": "dc",
        "body": [
            "{${1:key}: ${2:value} for ${3:item} in ${4:iterable}}"
        ],
        "description": "Dictionary comprehension"
    },
    "Lambda": {
        "prefix": "lambda",
        "body": [
            "lambda ${1:params}: ${0:expression}"
        ],
        "description": "Lambda function"
    },
    "Use Import": {
        "prefix": "use",
        "body": [
            "use ${1:module}${2: as ${3:alias}}"
        ],
        "description": "Import a module with use"
    },
    "Enum Definition": {
        "prefix": "enum",
        "body": [
            "enum ${1:EnumName}:",
            "    ${2:Variant1}: (${3:Type})",
            "    ${0:Variant2}"
        ],
        "description": "Define a new enum"
    },
    "Doc Comment": {
        "prefix": "doc",
        "body": [
            "\"\"\"",
            "${0:Description}",
            "\"\"\""
        ],
        "description": "Documentation comment"
    },
    "Function with Type Hints": {
        "prefix": "fnt",
        "body": [
            "fn ${1:function_name}(${2:param}: ${3:Type}) -> ${4:ReturnType}:",
            "    ${0:pass}"
        ],
        "description": "Function with type hints"
    },
    "Property Decorator": {
        "prefix": "prop",
        "body": [
            "@property",
            "fn ${1:property_name}(self):",
            "    return self._${1:property_name}"
        ],
        "description": "Property decorator"
    },
    "Context Manager": {
        "prefix": "with",
        "body": [
            "with ${1:expression} as ${2:variable}:",
            "    ${0:pass}"
        ],
        "description": "With statement (context manager)"
    },
    "List Comprehension with Filter": {
        "prefix": "lcf",
        "body": [
            "[${1:expr} for ${2:item} in ${3:iterable} if ${4:condition}]"
        ],
        "description": "List comprehension with filter"
    },
    "Generator Expression": {
        "prefix": "gen",
        "body": [
            "(${1:expr} for ${2:item} in ${3:iterable})"
        ],
        "description": "Generator expression"
    },
    "Assert Statement": {
        "prefix": "assert",
        "body": [
            "assert ${1:condition}, \"${2:error message}\""
        ],
        "description": "Assert with message"
    },
    "Dataclass": {
        "prefix": "dataclass",
        "body": [
            "@dataclass",
            "class ${1:ClassName}:",
            "    ${2:field}: ${3:Type}",
            "    ${0}"
        ],
        "description": "Dataclass definition"
    },
    "Type Alias": {
        "prefix": "type",
        "body": [
            "type ${1:AliasName} = ${0:Type}"
        ],
        "description": "Type alias"
    },
    "Pattern Match with Guard": {
        "prefix": "matchg",
        "body": [
            "match ${1:value}:",
            "    case ${2:pattern} if ${3:guard}:",
            "        ${0:pass}"
        ],
        "description": "Match with guard clause"
    },
    "Decorator": {
        "prefix": "deco",
        "body": [
            "@${1:decorator_name}",
            "fn ${2:function_name}(${3:params}):",
            "    ${0:pass}"
        ],
        "description": "Function with decorator"
    },
    "Option Enum": {
        "prefix": "option",
        "body": [
            "enum Option<T>:",
            "    Some: (T)",
            "    None"
        ],
        "description": "Option enum definition"
    },
    "Match Option": {
        "prefix": "optmat",
        "body": [
            "match ${1:option}:",
            "    case Option.Some(${2:value}):",
            "        ${3:pass}",
            "    case Option.None:",
            "        ${0:pass}"
        ],
        "description": "Match Option with Some/None cases"
    },
    "Result Unwrap": {
        "prefix": "resunw",
        "body": [
            "match ${1:result}:",
            "    case Result.Ok(${2:value}):",
            "        ${2:value}",
            "    case Result.Err(${3:error}):",
            "        panic(\"${0:error}\")"
        ],
        "description": "Unwrap Result or panic"
    },
    "Result Chain": {
        "prefix": "resch",
        "body": [
            "match ${1:result1}:",
            "    case Result.Ok(${2:value1}):",
            "        match ${3:result2}:",
            "            case Result.Ok(${4:value2}):",
            "                Result.Ok(${5:value1 + value2})",
            "            case Result.Err(${6:error}):",
            "                Result.Err(${6:error})",
            "    case Result.Err(${7:error}):",
            "        Result.Err(${7:error})"
        ],
        "description": "Chain multiple Result operations"
    },
    "Multiline String": {
        "prefix": "mls",
        "body": [
            "\"\"\"",
            "${0:text}",
            "\"\"\""
        ],
        "description": "Multiline string"
    },
    "F-String": {
        "prefix": "fstr",
        "body": [
            "f\"${1:text} {${2:variable}}\""
        ],
        "description": "Formatted string"
    },
    "Walrus Operator": {
        "prefix": "walrus",
        "body": [
            "if (${1:var} := ${2:expression}):",
            "    ${0:pass}"
        ],
        "description": "Assignment expression (walrus operator)"
    }
}
